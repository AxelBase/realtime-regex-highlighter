import{f as p,a as i}from"../chunks/D10hzOpO.js";import"../chunks/DA0yb3uu.js";import{a4 as o,a8 as v,a3 as f,ac as u,ad as y,ae as t,a6 as r,a7 as l}from"../chunks/DcsHRKm5.js";import{h as b}from"../chunks/BFYyMXHm.js";import{s as c}from"../chunks/Bdg17N_2.js";import{b as n}from"../chunks/BspXlFui.js";const x=!0,S=Object.freeze(Object.defineProperty({__proto__:null,prerender:x},Symbol.toStringTag,{value:"Module"}));var k=p('<meta name="description" content="Deep dive into the Svelte reactivity and safe RegExp execution that powers instant highlighting without page reloads."/> <meta property="og:title" content="How Real-Time Regex Highlighting Works Under the Hood"/> <meta property="og:description" content="Explore the technical magic behind zero-latency regex matching in the browser using Svelte stores and safe exec loops."/> <meta property="og:url"/> <meta property="og:type" content="article"/> <meta name="twitter:card" content="summary_large_image"/>',1),z=p('<div class="container fade-in post-layout svelte-1apmzc4"><div class="breadcrumbs svelte-1apmzc4"><a class="svelte-1apmzc4">Blog</a><span>/</span><p>How Real-Time Highlighting Works</p></div> <article class="prose svelte-1apmzc4"><h1>How Real-Time Regex Highlighting Works Under the Hood</h1> <p class="post-meta">Published: November 29, 2025 • 7 min read</p> <p>You type a character → matches instantly appear highlighted. It feels like magic, but it’s just clever Svelte reactivity combined with safe RegExp handling.</p> <h2>Svelte Stores + Reactive Statements = Magic</h2> <p>The core of the tool uses three writable stores: <code class="svelte-1apmzc4">text</code>, <code class="svelte-1apmzc4">pattern</code>, and <code class="svelte-1apmzc4">flags</code>. A single reactive block watches all three:</p> <pre><code class="svelte-1apmzc4">$: result = highlightText($text, $pattern, $flags);</code></pre> <p>Every keystroke triggers this block, rebuilding the highlighted HTML in microseconds.</p> <h2>Safe Regex Execution (No Infinite Loops)</h2> <p>The biggest danger in real-time regex tools is zero-length matches (e.g. <code class="svelte-1apmzc4">^</code> or <code class="svelte-1apmzc4">(?:)</code>) causing infinite loops. We prevent this by:</p> <ul><li>Using a fresh <code class="svelte-1apmzc4">RegExp</code> copy on each loop</li> <li>Manually advancing <code class="svelte-1apmzc4">lastIndex</code> on empty matches</li> <li>Escaping HTML to prevent injection</li></ul> <h2>Why We Chose Client-Side Only</h2> <p>Zero server cost. Zero privacy risk. Instant response. Works offline. Deployable as a static site on GitHub Pages, Netlify, Vercel — anywhere.</p> <h2>FAQ</h2> <details><summary>What happens with catastrophic backtracking?</summary> <p>JavaScript regex engine handles it gracefully — worst case is a brief freeze, never a crash.</p></details> <details><summary>Why not use Web Workers?</summary> <p>Tried it. The serialization cost killed the “instant” feel. Direct main-thread execution is faster for this use case.</p></details> <p class="italic-note">Want to see the source? It’s all on GitHub — fork it, tweak it, make it yours.</p></article></div>');function $(h){var e=z();b("1apmzc4",m=>{var s=k(),d=v(f(s),6);t(4),o(()=>c(d,"content",`${n??""}/blog/posts/post2`)),u(()=>{y.title="How Real-Time Regex Highlighting Works Under the Hood"}),i(m,s)});var a=r(e),g=r(a);t(2),l(a),t(2),l(e),o(()=>c(g,"href",`${n??""}/blog`)),i(h,e)}export{$ as component,S as universal};
